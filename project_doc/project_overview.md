# All Project Context

Tôi đang cần triển khai một hệ thống ChatBot chăm sóc khác hàng trên fanpage facebook cho một ngân hàng. Trong đó hệ thống cần đảm bảo các mục tiêu sau:

- Mục tiêu trả lời tự động comment và tin nhắn gửi đến fanpage facebook.
- ChatBot với nền tảng là AI Agent có nhiệm vụ tự động trả lời nếu có thể, bóc tách ý định người dùng (ý định của người dùng, topic người dùng quan tâm), phân loại người dùng (Khách hàng cá nhân, KH doanh nghiệp, KH hộ kinh doanh, KH đối tác), tự đánh giá mức độ chính xác của câu trả lời tự động và phân loại thành tự động phản hồi (auto) và trả lời thủ công (manual).
- Hệ thống sẽ tự động chuyển câu trả lời của chatbot về cho người dùng trong trường hợp độ chính xác của câu trả lời đạt xx%, trong trường hợp ngược lại, câu hỏi của người dùng cùng với câu trả chatbot gợi ý cho một đội ngũ office (Business Unit) của ngân hàng để đội ngũ này review và trả lời trực tiếp.
- Thông tin của người dùng phải được thu thập và lưu trữ từ hai nguồn:

1. Thông tin của người này trên facebook
2. Thông tin của người này do AI Agent phân tích ra như: ý định của người này, loại khách hàng (customer type), ý định khách hàng, hay xa hơn có thể là hành vi trong quá khứ của khách hàng (đã từng mở thẻ, đã từng hỏi về chủ đề a,b,c,....)

- Những bản review của Business unit được lưu trữ lại để cải thiện câu trả lời của AI.
- Hệ thống phải hoạt động thời gian thực, câu hỏi của người dùng phải được trả lời sớm nhất có thể để đảm bảo trải nghiệm khách hàng.
- Phân phối tin nhắn được đánh nhãn "manual" đến các reviewer phù hợp dựa trên nhãn phân loại khách hàng và round robin.

# Solution Introduction

What is your solution?
Our solution is to design and build a customer service (CS) system on VPBank's Facebook Fanpage platform using an AI Agent deployed on the cloud. The system is capable of classifying, managing, and responding to users efficiently.
Discuss main features clearly.

1. The system integrates with Facebook Webhook to automatically collect comments and messages from the Fanpage in real time.
2. The BU can monitor, manage, and respond to all customer interactions through an intuitive dashboard.
3. The AI Agent analyzes, classifies users, and generates appropriate responses based on the knowledge base.
4. Uncertain queries are routed to the most suitable reviewers using a smart load and expertise-based algorithm.
5. Reviewers can respond instantly to manually tagged questions through a live chat interface.
6. Reviewer feedback is recorded and used to continuously improve the AI via reinforcement learning.

How does your solution work?
Our solution utilizes the following key components: 7. Knowledge Management System  
 This system stores and manages real-time knowledge data about the bank, such as customer guides, forms/fees, updated information, card issuance procedures, etc. These data are securely stored internally and serve as the foundation for generating automated responses by the AI Agent.  
8. AI Agent System for Automatic Classification and Response Generation  
 a. The AI Agent analyzes user queries, retrieves relevant documents from the knowledge base, and incorporates them into the context for the large language model. This enables the system to classify users and generate appropriate responses.  
 b. The AI Agent is composed of multiple components, each handling specific tasks such as summarizing chat history, analyzing user intent, retrieving related documents, generating responses, validating responses, and assessing response confidence.  
 c. Every message from users is processed and analyzed by the AI Agent.  
 d. Every response generated by the AI is validated and its confidence level is calculated.  
Application Interface for Business Units (BU)  
The application interface allows VPBank’s consultants and administrators (collectively referred to as the Business Unit – BU) to directly and intuitively respond to questions that have been tagged as “manual.”\*\*

# Architecture of solution

\*\*

1. AI Agent System
2. User Memory Management:

- Technologies: Amazon S3 + Amazon DynamoDB
- Why we use: Amazon S3 to store full conversation transcripts, knowledge artifacts, and historical question-answer pairs. These data are structured into objects and organized by user sessions, enabling long-term memory and auditability. For fast access to contextual metadata (e.g., last question, last response, active status), we use Amazon DynamoDB. This allows the AI Agent to access memory and retrieve relevant context in real-time to improve follow-up interactions.

1. Knowledge Embedding Storage

- Technologies: Amazon OpenSearch (with k-NN plugin)
- Why we use: After knowledge documents are preprocessed and embedded, the resulting vectors are stored in Amazon OpenSearch with vector similarity search enabled. The Searcher agent queries this service to retrieve semantically similar knowledge passages, enabling fast and accurate retrieval from a large corpus.

2. Compute & Orchestration

- Technologies: AWS Lambda + Step Functions + ECS
- Why we use: Lightweight operations such as message intake, query preprocessing, and post-processing logic are handled using AWS Lambda for scalability and cost-efficiency. The core AI Agent modules (e.g., BERT inference, summarizer) run inside containerized services on Amazon ECS (Fargate) for controlled GPU/CPU usage and scaling on demand.

2. Message Queueing

- Technologies: Amazon SQS
- Why we use: To ensure decoupling and fault tolerance between services, we use Amazon SQS to queue messages between agents (e.g., from Receptionist to Analyst, or from Searcher to Validator). This prevents bottlenecks and enables retries in case of transient failures.

2. Backend system

3. External Integration Layer
4. Facebook Platform:
5. Customer: Interacts by sending comments or inbox messages.
6. Functionality: Receives low-accuracy comments via webhook, triggering events for further processing.
7. VPBank:
8. VP Bank Reviewer: Reviews low-accuracy comments and updates the knowledge base via webhook.
9. Functionality: Provides transaction data or feedback to refine AI models.
10. Backend Layer
11. Worker Node: Runs containerized backend services on Amazon EC2.
12. Amazon RDS: Stores relational data (e.g., user profiles, transaction history) with automatic backups and scaling.
13. Functionality: Handles API requests, processes transactions, and manages jar allocations. Communicates asynchronously with the AI agent layer.

14. Async Communication:
15. Sends update events and knowledge base updates to the AI agent via AWS SOS (Simple Queue Service).
16. AI Agent Layer
17. AI Agent Auto-Scaling Group:
18. Worker Node: Hosts AI inference services on Amazon EKS, utilizing models like Llama2 for transaction classification and RAG for coaching.
19. Vector Database: Stores embeddings and knowledge base data for efficient retrieval and AI processing.
20. Functionality: Classifies transactions, generates personalized financial advice, and updates the knowledge base based on reviewer feedback.
21. Data Storage and Processing
22. Amazon RDS: Primary relational database for structured data (e.g., user data, jar allocations).
23. Vector Database: Specialized storage for AI embeddings and knowledge base, integrated with the AI agent layer.
24. AWS SQS: Facilitates asynchronous message passing between backend and AI agents.
25. Trigger: An AWS Lambda function processes SQS events, updating the vector database with new knowledge base data.
26. AWS Cloud Infrastructure
27. Data Flow
28. Customer Interaction: Users send comments via the Facebook platform, triggering a webhook event
29. Backend Processing: The worker node processes the event, querying Amazon RDS for user data and sending updates to the AI agent via SOS.
30. AI Processing: The AI agent worker node classifies transactions and generates recommendations using the vector database, then returns results to the backend.
31. Feedback Loop: VPBank reviewers update the knowledge base, which is sent via webhook and processed by the trigger to update the vector database.
32. Response: The backend sends processed data (e.g., jar updates, alerts) back to the user interface.
33. Scalability and Reliability
    Fault Tolerance: Load balancer and SOS handle failures by rerouting traffic and queuing tasks.\*\*

# All Project Brief

Toàn bộ project lớn sẽ bao gồm các component sau đây:

- Facebook integration backend: backend service này chịu trách nhiệm nhận hooks từ facebook để nhận tin nhắn, comment, thực hiện de-duplication và sau đó gọi hook sang Backend chính
- Backend chính: service này chịu trách nhiệm xử lý chính tất cả các chức năng bao gồm: nhận yêu cầu tin nhắn (hooks) từ FB integration backend và gọi sang AI Agent để sinh câu trả lời tự động và phân tích người dùng. sau đó quyết định trả lời về Facebook Backend hay sẽ gửi sang để manual review, đồng thời quản lý thông tin người dùng, xác thực đăng nhập, phân phối các bản tin nhắn đến reviewer theo cài đặt.
- AI Agent: service này cung cấp 1 đầu API để Backend gọi sang để lấy ra câu trả lời tự động
- FrontEnd Dashboard: Frontend này là dashboard dành cho Reviewer của Business Unit của ngân hàng, chịu trách nhiệm hiển thị danh sách tin nhắn, nhận thông báo, cho phép reviewer trả lời tin nhắn và cho phép quản lý Knowledge base
- Knowledge base: đây là cơ sở dữ liệu riêng biệt hẳn so với các backend, quản lý vùng dữ liệu hiểu biết của AI Agent, Backend sẽ k có quyền quản lý vùng này

# This project context

Project này là phần Backend của hệ thống, đảm nhận nhiệm vụ:

- Xử lý điều hướng các luồng tin nhắn (nhận từ đầu xử lý facebook bằng webhook, chuyển tin nhắn đến dashboard frontend bằng socketIO)
- Xử lý lưu trữ thông tin người dùng
- xử lý lưu trữ quản lý, lưu trữ Knowledge base.

Các luồng chính:

- tính năng đăng nhập tài khoản cho admin, reviewer
- Tính năng quản lý quyền truy cập cho admin
- Tính năng tạo tài khoản mới cho admin
- Tính năng quên tài khoản
- Luồng xử lý tin nhắn mới từ đầu facebook
- Luồng phân phối tin nhắn "manual" đến cho reviewer
- Luồng reviewer trả lời tin nhắn
- Luồng lấy thông tin khách hàng
- Luồng các config xử lý tin nhắn (độ chính xác bao nhiêu thì trả lời manual và ngược lại là auto)
- Các settings ở frontend (light/dark mode,...)

## Luồng đăng nhập tài khoản admin, reviewer

Thực chất, Project không phân biệt role admin, reviewer mà nhận biết thông qua một tập hợp quyền.
Các tác nhân của hệ thống mà backend giao tiếp là:

- Khách hàng
- User của ngân hàng (Business Unit)
- AI Agent
  Các tài khoản hoạt động trong hệ thống được tạo bởi một tài khoản master admin ban đầu (tài khoản này có tất cả quyền của hệt hống).
  Mỗi tài khoản sẽ đăng nhập bằng username và password.
  Hệ thống được bảo mật bằng JWT.
  Một user phải có trạng thái active để biết account có đang hoạt động hay không hay bị đình chỉ.
  Một user phải có trạng thái requireChangePassword để biết cần đổi mật khẩu trước khi đăng nhập vào hay không.

## Tính năng quản lý quyền truy cập

Mỗi account trong hệ thống được cấp một bộ quyền truy cập (kể cả tài khoản admin).
Quyền của các account được quản lý dưới dạng cấu trúc một bảng hai chiều, cột là danh sách user, hàng là các quyền tương ứng. Bao gồm các quyền sau đây:
|Tên quyền (enum value)|Ghi chú|
|chat|Có quyền vào các trang chat, gửi tin nhắn, nhận tin nhắn,....|
|kb|Có quyền vào các trang update update knowledge|
|permission|Có quyền vào các trang quản lý user, quản lý phân quyền, tạo tài khoản user mới|
|customer_type|có quyền vào các trang quản lý tệp khách hàng phụ trách|

Ví dụ việc phân quyền:
|User|chat|kb|permission|customer_type|
|admin master|x|x|x|x|
|user1|x| - | - | - |
|user2|x| - | - | x |

Mỗi user (có quyền chat- tức là thưc hiện trả lời thủ công tin nhắn), sẽ được gán phục trách một hoặc nhiều phân loại khách hàng khác nhau. Tương tự như quyền, gán phân loại khách hàng cho user cũng được biểu diễn dưới dạng một bảng 2 chiều.

## Tính năng tạo tài khoản mới cho admin

admin có quyền permission có thể tạo tài khoản mới cho user.

## Tính năng quên mật khẩu

Tính năng cho phép một user thay đổi password, có xử lý OTP gửi về email

## Tính năng đổi password

Tính năng cho phép một user thay đổi password

# Tính năng chat

Cuộc trò chuyện với mỗi Khách hàng (customer) được coi là một đối tượng conversation.
Mỗi conversation sẽ bao gồm 3 tác nhân (customer, ai agent, reviewer được gán).

Một message trong hệ thống phải có các thuộc tính chỉ ra: 1. Id của tin nhắn 2. ConversationId của tin nhắn 3. CustomerId của tin nhắn 4. sender_id thể hiện id của người gửi (id của customer hoặc user) 5. sender_type: bot hay user 6. content 7. created_at 8. updated_at 9. auto_response nội dung auto_response nếu có

Một redisDB được sử dụng để lưu trữ các tin nhắn cần gửi về cho FB integration Backend.
Một redisDB được sử dụng để lưu trữ các tin nhắn đang xử lý (chưa gửi auto response về cho customer, cũng chưa nhận được reply từ Business Unit, việc lưu trữ này nhằm thực hiện retry hoặc phân phối lại cho các user Business Unit - hay các reviewer khác).
Một hệ thống Database để lưu trữ lâu dài.

Các trạng thái của một tin nhắn có thể như sau:

1. Received
2. Wait AI Agent
3. ai agent done, need manual
4. ai agent done, auto
5. Auto response done
6. sent to reviewer
7. sent to reviewer, sent waiting message
8. reviewer replied
9. manu response done

Luồng cho một tin nhắn mới đến hệ thống như sau:

1. Một tin nhắn mới từ Facebook Integration Backend gửi đến backend qua gọi webhook.
2. Lưu trữ tin nhắn này xuống redis với trạng thái "received". Lưu trữ tin nhắn vào conversation.
3. Gọi sang AI Agent để lấy auto response, phân tích customer và độ chính xác dự kiến (confidence). Đặt trạng thái là wait ai agent.
4. Có được response từ AI Agent, kiểm tra confidence so với config của hệ thống (xx%)
   4.1. Nếu confidence >= xx%, lưu câu trả lời của ai agent, đặt trạng thái là "ai agent done, auto", sẵn sàng trả về cho đầu facebook backend. Lưu trữ vào conversation. Kết thúc luồng.
   4.2. Nếu confidence < xx%, thực hiện dựa vào các yếu tố (trình bày ở phần sau) để phân phối đến 1 reviewer. Đánh dấu là "sent_to_reviewer". gắn id của reviewer chịu trách nhiệm review.
5. Lưu trữ các thông tin insight về người dùng mà ai agent phân tích được và cào được từ facebook vào DB
6. Sau khi gửi cho reviewer, nếu hệ thống config có gửi waiting message (một tin nhắn yêu cầu customer vui lòng chờ một chút để hệ thống xử lý), thì lấy waiting message gắn vào response và đặt trạng thái là "sent to reviewer, sent waiting message". Lưu trữ tin nhắn mới này vào conversation và bắn sang frontend.
   6.1. Nếu reviewer đã xem xét và reply lại: Đánh dấu "reviewer replied" và sẵn sàng gửi về facebook, đồng thời lưu trữ tin nhắn mới vào conversation
   6.2. Nếu reviewer quá lâu không phải hồi hoặc đột ngột offline hoặc offline khi chưa đánh dấu là xử lý xong case này: Gửi lại cho reviewer khác và tăng số retry.
7. Một job sẽ gửi tin nhắn về đầu facebook và đánh dấu "manu response done", kết thúc luồng.

Các job là CronJob, chạy liên tục để xử lý các tác vụ cần thiết.

## Giao tiếp giữa backend và frontend để xử lý chat

Chat là tác vụ realtime, do đó ta sử dụng socketIO để giao tiếp giữa backend và frontend.
Khi user đăng nhập frontend, frontend sẽ kết nối với backend thông qua socketIO và gửi một event "connect_socket" với data là user_id để backend biết user đã đăng nhập.
Backend sẽ lưu trữ các phiên đăng nhập của user vào redisDB. bao gồm user_id, socket_id, created_at, updated_at.

Khi thực hiện phân phối tin nhắn đến reviewer, backend sẽ xem xét các reviewer đang online và có quyền "chat", đồng thời xem xét lịch sử chat và loại khách hàng phụ trách của reviewer đó. Cụ thể về cách thức phân phối sẽ được mô tả chi tiết ở phần sau.

Khi phân phối một tin nhắn mới đến frontend, backend sẽ gửi một event "receive_mess" đến frontend. Data là một đối tượng message có các thuộc tính:

1. Id của tin nhắn 2. ConversationId của tin nhắn 3. CustomerId của tin nhắn 4. sender_id thể hiện id của người gửi (id của customer hoặc user) 5. sender_type: bot hay user 6. content 7. created_at 8. updated_at 9. auto_response nội dung auto_response

Khi reviewer trả lời tin nhắn, backend sẽ gửi một event "send_message" đến frontend. Data là một đối tượng bao gồm:
conversation_id
sender_id
content

### API của AI Agent

AI Agent là một service riêng biệt, được deploy trên AWS ECS.
AI Agent có 1 đầu API để backend gọi sang để lấy ra câu trả lời tự động.
URL: http://127.137.129.161:8080/api (url nên được cấu hình trong environment variable)

Method: POST
Body:
question: string (câu hỏi của khách hàng)
api_key: string (api key của AI Agent), mặc định None
model_name: string (tên model của AI Agent), mặc định là gpt-4.1, có thể được config trong system config của backend

Response:
answer: string (câu trả lời tự động)
confidence: double (độ chính xác của câu trả lời tự động)
clarified_query: string (câu hỏi đã được làm rõ)
customer_type: string (loại khách hàng, tương ứng với enum CustomerType)
key_information: string (những keyword quan trọng trong câu hỏi)
main_topic: string (chủ đề chính trong câu hỏi)
question: string (câu hỏi gốc)

### Những việc cần làm để triển khai phần xử lý tin nhắn của hệ thống

Phiên bản Scaleable:

1. webhook để nhận tin nhắn từ đầu facebook
2. kết nối redis để cache tin nhắn
3. kết nối database để lưu trữ tin nhắn
4. Tạo các API liên quan đến customer bao gồm: create customer, get customer, update customer
5. Tạo các API liên quan đến tin nhắn bao gồm: get listchat (theo user id) (hay là conversations), get messages (theo conversation id)
6. Tạo các socketIO event và phần xử lý event, caching online reviewer
7. Job Xử lý phân phối tin nhắn đến reviewer
8. Kết hợp để hoàn thành luồng xử lý tin nhắn

Phiên bản non-scale:

1. webhook để nhận tin nhắn từ đầu facebook
2. kết nối redis để cache reviewer đang online
3. kết nối database để lưu trữ tin nhắn
4. Tạo các API liên quan đến customer bao gồm: create customer, get customer, update customer
5. Tạo các API liên quan đến tin nhắn bao gồm: get listchat (theo user id) (hay là conversations), get messages (theo conversation id)
6. Tạo các socketIO event và phần xử lý event, caching online reviewer

---

Từ khi có tin nhắn mới gửi đến webhook, backend sẽ lưu trữ tin nhắn vào database, Backend gọi từ webhook sang một hàm controller.
Hàm controller này thực hiện:

1. Gọi sang AI Agent để lấy câu trả lời tự động
2. Có được Phân tích khách hàng (customer_type) và độ chính xác dự kiến (confidence), câu trả lời tự động.
3. Kiểm tra customer tồn tại trên hệ thống hay chưa (thông qua fb_id), tạo mới nếu cần. Lưu trữ thông tin phân tích khách hàng vào DB. Gắn customer_type vào customer. Gắn customer_id vào tin nhắn. Tạo conversation với khách hàng. Một conversation sẽ gắn với một khách hàng và một reviewer (gắn với 2 người).
4. Gọi sang hàm để Tìm kiếm reviewer phù hợp (đang online, có quyền chat, ưu tiên có lịch sử chat với customer này, ưu tiên cùng loại khách hàng)
5. Gửi tin nhắn đến socket_id tương ứng với reviewer đó.
6. Gửi socket_event đến reviewer đó.
7. Xử lý sự kiện sau khi nhận socket_event từ reviewer: kiểm tra conversation_id và update message vào.
8. Thêm message này vào redis cache để job gửi về đầu facebook_backend.

### Phương pháp phân phối tin nhắn đến reviewer

- Từ cache các user đang online -> lấy ra các user có quyền chat.
  Phân phối tin nhắn đến các user đã lấy ra theo độ ưu tiên:

1. Có lịch sử chat với customer này
2. Cùng loại khách hàng
